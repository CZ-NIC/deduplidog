{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Deduplidog","text":"<p>A deduplicator that covers your back.</p> <ul> <li>About</li> <li>What are the use cases?</li> <li>What is compared?</li> <li>Why not using standard sync tools like meld?</li> <li>Doubts?</li> <li>Launch</li> <li>Examples</li> <li>Duplicated files</li> <li>Names shuffled</li> <li>Documentation</li> </ul>"},{"location":"#about","title":"About","text":""},{"location":"#what-are-the-use-cases","title":"What are the use cases?","text":"<ul> <li>I have downloaded photos and videos from the cloud. Oh, both Google Photos and Youtube shrink the files and change their format. Moreover, they shorten the file names to 47 characters and capitalize the extensions. So how am I supposed to know if I have everything backed up offline when the copies are resized?</li> <li>My disk is cluttered with several backups and I'd like to be sure these are all just copies.</li> <li>I merge data from multiple sources. Some files in the backup might have the former orignal file modification date that I might wish to restore.</li> </ul>"},{"location":"#what-is-compared","title":"What is compared?","text":"<ul> <li>The file name.</li> </ul> <p>Works great when the files keep more or less the same name. (Photos downloaded from Google have its stem shortened to 47 chars but that is enough.) Might ignore case sensitivity.</p> <ul> <li>The file date.</li> </ul> <p>You can impose the same file mtime, tolerate few hours (to correct timezone confusion) or ignore the date altogether.</p> <p>Note: we ignore smaller than a second differences.</p> <ul> <li>The file size, the image hash or the video frame count.</li> </ul> <p>The file must have the same size. Or take advantage of the media magic under the hood which ignores the file size but compares the image or the video inside. It is great whenever you end up with some files converted to a different format.</p> <ul> <li>The contents?</li> </ul> <p>You may use <code>checksum=True</code> to perform CRC32 check. However for byte-to-byte checking, when the file names might differ or you need to check there is no byte corruption, some other tool might be better way, i.e. jdupes.</p>"},{"location":"#why-not-using-standard-sync-tools-like-meld","title":"Why not using standard sync tools like meld?","text":"<p>These imply the folders have the same structure. Deduplidog is tolerant towards files scattered around.</p>"},{"location":"#doubts","title":"Doubts?","text":"<p>The program does not write anything to the disk, unless <code>execute=True</code> is set. Feel free to launch it just to inspect the recommended actions. Or set <code>inspect=True</code> to output bash commands you may launch after thorough examining.</p>"},{"location":"#launch","title":"Launch","text":"<p>Install with <code>pip install deduplidog</code>.</p> <p>It works as a standalone program with all the CLI, TUI and GUI interfaces. Just launch the <code>deduplidog</code> command.</p>"},{"location":"#examples","title":"Examples","text":""},{"location":"#media-magic-confirmation","title":"Media magic confirmation","text":"<p>Let's compare two folders.</p> <pre><code>deduplidog --work-dir folder1 --original-dir folder2  --media-magic --rename --execute\n</code></pre> <p>By default, <code>--confirm-one-by-one</code> is True, causing every change to be manually confirmed before it takes effect. So even though <code>--execute</code> is there, no change happen without confirmation. The change that happen is the <code>--rename</code>, the file in the <code>--work-dir</code> will be prefixed with the <code>\u2713</code> character. The <code>--media-magic</code> mode considers an image a duplicate if it has the same name and a similar image hash, even if the files are of different sizes.</p> <p></p> <p>Note that the default button is 'No' as there are some warnings. First, the file in the folder we search for duplicates in is bigger than the one in the original folder. Second, it is also older, suggesting that it might be the actual original.</p>"},{"location":"#duplicated-files","title":"Duplicated files","text":"<p>Let's take a closer look to a use-case.</p> <pre><code>deduplidog --work-dir /home/user/duplicates --original-dir /media/disk/origs\" --ignore-date --rename\n</code></pre> <p>This command produced the following output:</p> <pre><code>Find files by size, ignoring: date, crc32\nDuplicates from the work dir at 'home' would be (if execute were True) renamed (prefixed with \u2713).\nNumber of originals: 38\n* /home/user/duplicates/foo.txt\n  /media/disk/origs/foo.txt\n  \ud83d\udd28home: renamable\n  \ud83d\udcc4media: DATE WARNING + a day \ud83d\udedfskipped on warning\nAffectable: 37/38\nAffected size: 56.9 kB\nWarnings: 1\n</code></pre> <p>We found out all the files in the duplicates folder seem to be useless but one. It's date is earlier than the original one. The life buoy icon would prevent any action. To suppress this, let's turn on <code>set_both_to_older_date</code>. See with full log.</p> <pre><code>deduplidog --work-dir /home/user/duplicates --original-dir /media/disk/origs --ignore-date --rename --set-both-to-older-date --log-level=10\n</code></pre> <pre><code>Find files by size, ignoring: date, crc32\nDuplicates from the work dir at 'home' would be (if execute were True) renamed (prefixed with \u2713).\nOriginal file mtime date might be set backwards to the duplicate file.\nNumber of originals: 38\n* /home/user/duplicates/foo.txt\n  /media/disk/origs/foo.txt\n  \ud83d\udd28home: renamable\n  \ud83d\udcc4media: redatable 2022-04-28 16:58:56 -&gt; 2020-04-26 16:58:00\n* /home/user/duplicates/bar.txt\n  /media/disk/origs/bar.txt\n  \ud83d\udd28home: renamable\n* /home/user/duplicates/third.txt\n  /media/disk/origs/third.txt\n  \ud83d\udd28home: renamable\n  ...\nAffectable: 38/38\nAffected size: 59.9 kB\n</code></pre> <p>You see, the log is at the most brief, yet transparent form. The files to be affected at the work folder are prepended with the \ud83d\udd28 icon whereas those affected at the original folder uses \ud83d\udcc4 icon. We might add <code>execute=True</code> parameter to perform the actions. Or use <code>inspect=True</code> to inspect.</p> <pre><code>deduplidog --work-dir /home/user/duplicates --original-dir /media/disk/origs --ignore-date --rename --set-both-to-older-date --inspect\n</code></pre> <p>The <code>inspect=True</code> just produces the commands we might subsequently use.</p> <pre><code>touch -t 1524754680.0 /media/disk/origs/foo.txt\nmv -n /home/user/duplicates/foo.txt /home/user/duplicates/\u2713foo.txt\nmv -n /home/user/duplicates/bar.txt /home/user/duplicates/\u2713bar.txt\nmv -n /home/user/duplicates/third.txt /home/user/duplicates/\u2713third.txt\n</code></pre>"},{"location":"#names-shuffled","title":"Names shuffled","text":"<p>You face a directory that might contain some images twice. Let's analyze. We turn on <code>media_magic</code> so that we find the scaled down images. We <code>ignore_name</code> because the scaled images might have been renamed. We <code>skip_bigger</code> files as we examine the only folder and every file pair would be matched twice. That way, we declare the original image is the bigger one. And we set <code>log_level</code> verbosity so that we get a list of the affected files.</p> <pre><code>$ deduplidog --work-dir ~/shuffled/ --media-magic --ignore-name --skip-bigger --log-level=20\nOnly files with media suffixes are taken into consideration. Nor the size nor the date is compared. Nor the name!\nDuplicates from the work dir at 'shuffled' (only if smaller than the pair file) would be (if execute were True) left intact (because no action is selected, nothing will happen).\n\nNumber of originals: 9\nCaching image hashes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 16.63it/s]\nCaching working files: 9it [00:00, 62497.91it/s]\n* /home/user/shuffled/IMG_20230802_shrink.jpg\n  /home/user/shuffled/IMG_20230802.jpg\nAffectable: 1/9\nAffected size: 636.4 kB\n</code></pre> <p>We see there si a single duplicated file whose name is <code>IMG_20230802_shrink.jpg</code>.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>See the docs overview at https://cz-nic.github.io/deduplidog/.</p>"},{"location":"Changelog/","title":"Changelog","text":""},{"location":"Changelog/#070-2025-01-09","title":"0.7.0 (2025-01-09)","text":"<p>Working as expected.</p>"},{"location":"Overview/","title":"Overview","text":""},{"location":"Overview/#deduplidog-overview","title":"Deduplidog overview","text":"<p>Launch <code>deduplidog</code> and change these parameter from GUI/TUI, or set them via CLI.</p> <p>Find the duplicates.</p> <p>Normally, the file must have the same size, date and name. (Name might be just similar if parameters like strip_end_counter are set.)</p> <p>If <code>media_magic=True</code>, media files receive different rules: Neither the size nor the date are compared. See its help.</p>"},{"location":"Overview/#deduplidog.Deduplidog.work_dir","title":"<code>work_dir: Path = Path.cwd()</code>","text":"<p>Folder of the files suspectible to be duplicates.</p>"},{"location":"Overview/#deduplidog.Deduplidog.original_dir","title":"<code>original_dir: Path | None = None</code>","text":"<p>Folder of the original files. Normally, these files will not be affected. (However, they might get affected by <code>treat_bigger_as_original</code> or <code>set_both_to_older_date</code>).</p>"},{"location":"Overview/#action","title":"Action","text":"<p>What is to be done with the duplicates.</p>"},{"location":"Overview/#deduplidog.deduplidog.Action.execute","title":"<code>execute: bool = False</code>","text":"<p>If False, nothing happens, just a safe run is performed.</p>"},{"location":"Overview/#deduplidog.deduplidog.Action.inspect","title":"<code>inspect: bool = False</code>","text":"<p>Print bash commands that correspond to the actions that would have been executed if execute were True. You can check and run them yourself.</p>"},{"location":"Overview/#deduplidog.deduplidog.Action.rename","title":"<code>rename: bool = False</code>","text":"<p>If <code>execute=True</code>, prepend \u2713 to the duplicated work file name (or possibly to the original file name if treat_bigger_as_original). Mutually exclusive with other execute action.</p>"},{"location":"Overview/#deduplidog.deduplidog.Action.delete","title":"<code>delete: bool = False</code>","text":"<p>If <code>execute=True</code>, delete theduplicated work file name (or possibly to the original file name if treat_bigger_as_original). Mutually exclusive with other execute action.</p>"},{"location":"Overview/#deduplidog.deduplidog.Action.replace_with_original","title":"<code>replace_with_original: bool = False</code>","text":"<p>If <code>execute=True</code>, replace duplicated work file with the original (or possibly vice versa if treat_bigger_as_original). Mutually exclusive with other execute action.</p>"},{"location":"Overview/#deduplidog.deduplidog.Action.replace_with_symlink","title":"<code>replace_with_symlink: bool = False</code>","text":"<p>If <code>execute=True</code>, replace duplicated work file with the relative symlink to the original (or possibly vice versa if treat_bigger_as_original). Its modification time is kept. Mutually exclusive with other execute action.</p>"},{"location":"Overview/#execution","title":"Execution","text":"<p>Parameters affecting the way the execution runs.</p>"},{"location":"Overview/#deduplidog.deduplidog.Execution.set_both_to_older_date","title":"<code>set_both_to_older_date: bool = False</code>","text":"<p>If <code>execute=True</code>, <code>media_magic=True</code> or (media_magic=False and <code>ignore_date=True</code>), both files are set to the older date. Ex: work file get's the original file's date or vice versa.</p>"},{"location":"Overview/#deduplidog.deduplidog.Execution.treat_bigger_as_original","title":"<code>treat_bigger_as_original: bool = False</code>","text":"<p>If <code>execute=True</code> and <code>rename=True</code> and <code>media_magic=True</code>, the original file might be affected (by renaming) if smaller than the work file.</p>"},{"location":"Overview/#deduplidog.deduplidog.Execution.skip_bigger","title":"<code>skip_bigger: bool = False</code>","text":"<p>If <code>media_magic=True</code>, all writing actions, such as <code>rename</code>, <code>replace_with_original</code>, <code>set_both_to_older_date</code> and <code>treat_bigger_as_original</code> are executed only if the affectable file is smaller (or the same size) than the other.</p>"},{"location":"Overview/#deduplidog.deduplidog.Execution.skip_empty","title":"<code>skip_empty: bool = False</code>","text":"<p>Skip files with zero size.</p>"},{"location":"Overview/#deduplidog.deduplidog.Execution.neglect_warning","title":"<code>neglect_warning: bool = False</code>","text":"<p>By default, when a file with bigger size or older date should be affected, just warning is generated. Turn this to suppress it.</p>"},{"location":"Overview/#deduplidog.deduplidog.Execution.confirm_one_by_one","title":"<code>confirm_one_by_one: bool = True</code>","text":"<p>Instead of executing changes all at once, confirm one by one. So that you may decide whether the media similarity detection works. If a warning occurs, the default is 'no' to perform the action.</p>"},{"location":"Overview/#match","title":"Match","text":"<p>The way the files are compared.</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.casefold","title":"<code>casefold: bool = False</code>","text":"<p>Case insensitive file name comparing.</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.checksum","title":"<code>checksum: bool = False</code>","text":"<p>If <code>media_magic=False</code> and <code>ignore_size=False</code>, files will be compared by CRC32 checksum. (This mode is considerably slower.)</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.tolerate_hour","title":"<code>tolerate_hour: int | tuple[int, int] | bool = False</code>","text":"<p>When comparing files in work_dir and <code>media_magic=False</code>, tolerate hour difference. Sometimes when dealing with FS changes, files might got shifted few hours. * bool \u2192 -1 .. +1 * int \u2192 -int .. +int * tuple \u2192 int1 .. int2 Ex: tolerate_hour=2 \u2192 work_file.st_mtime -7200 ... + 7200 is compared to the original_file.st_mtime</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.ignore_name","title":"<code>ignore_name: bool = False</code>","text":"<p>Files will not be compared by stem nor suffix.</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.ignore_date","title":"<code>ignore_date: bool = False</code>","text":"<p>If <code>media_magic=False</code>, files will not be compared by date.</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.ignore_size","title":"<code>ignore_size: bool = False</code>","text":"<p>If <code>media_magic=False</code>, files will not be compared by size.</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.space2char","title":"<code>space2char: bool = False</code>","text":"<p>When comparing files in work_dir, consider space as another char. Ex: \"file 012.jpg\" is compared as \"file_012.jpg\"</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.strip_end_counter","title":"<code>strip_end_counter: bool = False</code>","text":"<p>When comparing files in work_dir, strip the counter. Ex: \"00034(3).MTS\" is compared as \"00034.MTS\"</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.strip_suffix","title":"<code>strip_suffix: str = ''</code>","text":"<p>When comparing files in work_dir, strip the file name end matched by a regular. Ex: \"001-edited.jpg\" is compared as \"001.jpg\"</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.work_file_stem_shortened","title":"<code>work_file_stem_shortened: int | None = None</code>","text":"<p>Photos downloaded from Google have its stem shortened to 47 chars. For the comparing purpose, treat original folder file names shortened.</p>"},{"location":"Overview/#deduplidog.deduplidog.Match.invert_selection","title":"<code>invert_selection: bool = False</code>","text":"<p>Match only those files from work_dir that does not match the criterions.</p>"},{"location":"Overview/#media","title":"Media","text":"<p>Media files similarity detection.</p>"},{"location":"Overview/#deduplidog.deduplidog.Media.media_magic","title":"<code>media_magic: bool = False</code>","text":"<p>Media files similarity detection. Neither the size, date nor suffix is compared for files with media suffixes. A video is considered a duplicate if it has the same name and a similar number of frames, even if it has a different extension. An image is considered a duplicate if it has the same name and a similar image hash, even if the files are of different sizes. (This mode is considerably slower.)</p>"},{"location":"Overview/#deduplidog.deduplidog.Media.accepted_frame_delta","title":"<code>accepted_frame_delta: int = 1</code>","text":"<p>Number of frames for which two videos are considered equal.</p>"},{"location":"Overview/#deduplidog.deduplidog.Media.accepted_img_hash_diff","title":"<code>accepted_img_hash_diff: int = 1</code>","text":"<p>Hash difference between images so that they are considered equal, see https://github.com/JohannesBuchner/imagehash</p>"},{"location":"Overview/#deduplidog.deduplidog.Media.img_compare_date","title":"<code>img_compare_date: bool = False</code>","text":"<p>If True and <code>media_magic=True</code>, the work file date or the work file EXIF date must match the original file date (has to be no more than an hour around).</p>"},{"location":"Overview/#deduplidog.deduplidog.Media.img_max_size","title":"<code>img_max_size: int = 0</code>","text":"<p>Used only when media_magic is True. In the beginning, we preload the image hash of all the img in the original folder. This makes the hash calculation preload to skip if the file is bigger than this bytes. If you are searching for a relatively small image duplicates, you boost the original image hash caching speed by skipping the large ones.</p>"},{"location":"Overview/#helper","title":"Helper","text":"<p>Helper settings.</p>"},{"location":"Overview/#deduplidog.deduplidog.Helper.log_level","title":"<code>log_level: int = logging.WARNING</code>","text":"<p>10 debug .. 50 critical</p>"},{"location":"Overview/#deduplidog.deduplidog.Helper.output","title":"<code>output: bool = False</code>","text":"<p>Stores the output log to a file in the current working directory. (Never overwrites an older file.)</p>"},{"location":"Utils/","title":"Utils","text":""},{"location":"Utils/#utils","title":"Utils","text":"<p>The library might be invoked from a Jupyter Notebook.</p> <pre><code>from deduplidog import Deduplidog\nDeduplidog(\"/home/user/duplicates\", \"/media/disk/origs\", ignore_date=True, rename=True).start()\n</code></pre> <p>In the <code>deduplidog.utils</code> packages, you'll find a several handsome tools to help you. You will find parameters by using your IDE hints.</p>"},{"location":"Utils/#images","title":"<code>images</code>","text":"<p><code>urls: Iterable[str | Path]</code> Display a ribbon of images.</p>"},{"location":"Utils/#print_video_thumbs","title":"<code>print_video_thumbs</code>","text":"<p><code>src: str | Path</code> Displays thumbnails for a video.</p>"},{"location":"Utils/#print_videos_thumbs","title":"<code>print_videos_thumbs</code>","text":"<p><code>dir_: Path</code> To quickly understand the content of each video, output the duration and the first few frames.</p>"},{"location":"Utils/#get_frame_count","title":"<code>get_frame_count</code>","text":"<p><code>filename: str|Path</code> Uses cv2 to determine the video frame count. Method is cached.</p>"},{"location":"Utils/#search_for_media_wizzard","title":"<code>search_for_media_wizzard</code>","text":"<p><code>cwd: str</code> Repeatedly prompt and search for files with similar names somewhere in the specified path. Display all such files as images and video previews.</p>"},{"location":"Utils/#are_contained","title":"<code>are_contained</code>","text":"<p><code>work_dir: str, original_dir: str, sec_range: int = 60</code>  You got two dirs with files having different naming system (427.JPG vs DSC_1344)         which you suspect to contain the same set. The same files in the dirs seem to have the same timestamp.         The same timestamp means +/- sec_range (ex: 1 minute).         Loop all files from work_dir and display corresponding files having the same timestamp.         or warn that no original exists.</p>"},{"location":"Utils/#remove_prefix_in_workdir","title":"<code>remove_prefix_in_workdir</code>","text":"<p><code>work_dir: str</code> Removes the prefix \u2713 recursively from all the files. The prefix might have been previously given by the deduplidog.</p>"},{"location":"Utils/#mark_symlink_by_target","title":"<code>mark_symlink_by_target</code>","text":"<p><code>suspicious_directory: str | Path, starting_path: str</code> If the file is a symlink, pointing to this path, rename it with an arrow.</p> <pre><code>:param suspicious_directory: Ex: /media/user/disk/Takeout/Photos/\n:param starting_path: Ex: /media/user/disk\n</code></pre>"},{"location":"Utils/#mark_symlink_only_dirs","title":"<code>mark_symlink_only_dirs</code>","text":"<p><code>dir_: str | Path</code> If the directory is full of only symlinks or empty, rename it to an arrow.</p>"},{"location":"Utils/#mtime_files_in_dir_according_to_json","title":"<code>mtime_files_in_dir_according_to_json</code>","text":"<p><code>dir_: str | Path, json_dir: str | Path</code>  Google Photos returns JSON with the photo modification time. Sets the photos from the dir_ to the dates fetched from the directory with  these JSONs.</p>"}]}